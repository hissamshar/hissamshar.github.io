[{"content":"Running DeepSeek-R1 1.5B on Raspberry Pi 5 Technical Insights Why Can We Run This on Raspberry Pi 5? Thanks to open-source advancements, we can now run large-scale AI models on small devices like the Raspberry Pi 5. Key factors enabling this include:\nOptimized lightweight models: DeepSeek-R1 1.5B is built efficiently to run on limited hardware. ARM64 Support: Modern AI frameworks support ARM-based architectures, enabling their use on RPi5. Open-source software: Platforms like Ollama make AI deployment accessible to all. Performance Considerations Running this model on an RPi5 without a GPU will be CPU-intensive. Consider reducing active processes to free up memory. If performance lags, use a lighter model or external processing (cloud inference). This guide covers the installation and execution of DeepSeek-R1 1.5B on a Raspberry Pi 5, following the steps demonstrated in your images.\nPrerequisites Raspberry Pi 5 (ARM64 architecture, more powerful than previous versions) Debian-based Linux installed An internet connection At least 4GB RAM recommended for smooth operation Step 1: Log in to Your Raspberry Pi Upon booting, log in using your credentials:\nraspberrypi login: hisam Password: ****** Example login screen: Step 2: Install Curl Curl is required to fetch the installation script. Run:\nsudo apt install curl If it\u0026rsquo;s already installed, you\u0026rsquo;ll see:\ncurl is already the newest version... Example output: Step 3: Install Ollama Ollama is the runtime needed to execute DeepSeek models.\ncurl -fsSL https://ollama.com/install.sh | sh This will download and install Ollama.\nExample installation screen: Step 4: Enable and Start Ollama Service After installation, Ollama sets up a system service.\nollama The output will indicate success:\n\u0026gt;\u0026gt;\u0026gt; Creating ollama user... \u0026gt;\u0026gt;\u0026gt; Enabling and starting ollama service... \u0026gt;\u0026gt;\u0026gt; The Ollama API is now available at 127.0.0.1:11434. Example setup screen: Step 5: Pull and Run DeepSeek-R1 1.5B Now, pull and run the model:\nollama run deepseek-r1:1.5b This will download the model, which is about 1.1 GB in size.\nExample download screen: Once downloaded, the model is ready to run.\nStep 6: Execute DeepSeek-R1 1.5B Run the model and start interacting:\nollama run deepseek-r1:1.5b You should see a prompt where you can start typing queries:\n\u0026gt;\u0026gt;\u0026gt; Hey! Hello! How can I assist you today? ðŸ˜Š Example interaction: Final Setup Image (Placeholder for the final image you will add later)\nVideo Demonstration (Placeholder for video link once added)\nConclusion You have successfully installed and executed DeepSeek-R1 1.5B on your Raspberry Pi 5. This demonstrates the power of open-source AI, making it possible to run advanced models on small-scale devices. If you encounter performance issues, consider optimizing your setup or offloading computations.\nHappy coding!\n","permalink":"http://localhost:1313/posts/deepseek/","summary":"\u003ch1 id=\"running-deepseek-r1-15b-on-raspberry-pi-5\"\u003eRunning DeepSeek-R1 1.5B on Raspberry Pi 5\u003c/h1\u003e\n\u003ch2 id=\"technical-insights\"\u003eTechnical Insights\u003c/h2\u003e\n\u003ch3 id=\"why-can-we-run-this-on-raspberry-pi-5\"\u003eWhy Can We Run This on Raspberry Pi 5?\u003c/h3\u003e\n\u003cp\u003eThanks to open-source advancements, we can now run large-scale AI models on small devices like the Raspberry Pi 5. Key factors enabling this include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eOptimized lightweight models\u003c/strong\u003e: DeepSeek-R1 1.5B is built efficiently to run on limited hardware.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eARM64 Support\u003c/strong\u003e: Modern AI frameworks support ARM-based architectures, enabling their use on RPi5.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOpen-source software\u003c/strong\u003e: Platforms like Ollama make AI deployment accessible to all.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"performance-considerations\"\u003ePerformance Considerations\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eRunning this model on an RPi5 \u003cstrong\u003ewithout a GPU\u003c/strong\u003e will be CPU-intensive.\u003c/li\u003e\n\u003cli\u003eConsider \u003cstrong\u003ereducing active processes\u003c/strong\u003e to free up memory.\u003c/li\u003e\n\u003cli\u003eIf performance lags, use a \u003cstrong\u003elighter model\u003c/strong\u003e or \u003cstrong\u003eexternal processing (cloud inference).\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003eThis guide covers the installation and execution of DeepSeek-R1 1.5B on a Raspberry Pi 5, following the steps demonstrated in your images.\u003c/p\u003e","title":"DeepSEEK"},{"content":"Setting Up Neovim: An Easy and Beginner\u0026rsquo;s Guide Neovim is a modern and extensible text editor that enhances Vimâ€™s capabilities. If you\u0026rsquo;re using Linux, setting up Neovim can be a rewarding experience, allowing you to customize it for an efficient workflow. In this guide, we\u0026rsquo;ll cover installing Neovim, setting up a basic configuration, and enhancing it with essential plugins to turn it into a full-fledged IDE.\n1. Installing Neovim sudo pacman -S neovim 2. Setting Up Neovim Configuration Neovimâ€™s configuration is stored in ~/.config/nvim/. Create the directory and initialize a basic configuration:\nmkdir -p ~/.config/nvim nvim ~/.config/nvim/init.lua Minimal Configuration (init.lua) Add the following settings to your init.lua file:\n-- Enable line numbers vim.opt.number = true vim.opt.relativenumber = true -- Set tab size vim.opt.expandtab = true vim.opt.shiftwidth = 4 vim.opt.tabstop = 4 -- Enable mouse support vim.opt.mouse = \u0026#34;a\u0026#34; -- Set clipboard to system clipboard vim.opt.clipboard = \u0026#34;unnamedplus\u0026#34; Save and exit Neovim.\n3. Installing a Plugin Manager The best plugin manager for Neovim is lazy.nvim. Install it by running:\ngit clone --depth 1 https://github.com/folke/lazy.nvim.git \\ ~/.local/share/nvim/lazy/lazy.nvim Then, update your init.lua to load it:\nlocal lazypath = vim.fn.stdpath(\u0026#34;data\u0026#34;) .. \u0026#34;/lazy/lazy.nvim\u0026#34; if not vim.loop.fs_stat(lazypath) then vim.fn.system({ \u0026#34;git\u0026#34;, \u0026#34;clone\u0026#34;, \u0026#34;--filter=blob:none\u0026#34;, \u0026#34;https://github.com/folke/lazy.nvim.git\u0026#34;, lazypath }) end vim.opt.rtp:prepend(lazypath) 4. Installing Essential Plugins With lazy.nvim installed, you can add plugins in init.lua:\nrequire(\u0026#34;lazy\u0026#34;).setup({ \u0026#34;nvim-treesitter/nvim-treesitter\u0026#34;, -- Syntax highlighting \u0026#34;nvim-telescope/telescope.nvim\u0026#34;, -- Fuzzy finder \u0026#34;neovim/nvim-lspconfig\u0026#34;, -- LSP support \u0026#34;hrsh7th/nvim-cmp\u0026#34;, -- Auto-completion \u0026#34;hrsh7th/cmp-nvim-lsp\u0026#34;, -- LSP completion source \u0026#34;hrsh7th/cmp-buffer\u0026#34;, -- Buffer completion \u0026#34;hrsh7th/cmp-path\u0026#34;, -- Path completion \u0026#34;hrsh7th/cmp-nvim-lua\u0026#34;, -- Neovim Lua API completion \u0026#34;L3MON4D3/LuaSnip\u0026#34;, -- Snippet engine \u0026#34;saadparwaiz1/cmp_luasnip\u0026#34;, -- Snippet completion \u0026#34;nvim-lualine/lualine.nvim\u0026#34;, -- Status line \u0026#34;nvim-tree/nvim-tree.lua\u0026#34;, -- File explorer \u0026#34;tpope/vim-surround\u0026#34;, -- Surround text objects \u0026#34;tpope/vim-commentary\u0026#34;, -- Commenting shortcuts \u0026#34;lewis6991/gitsigns.nvim\u0026#34;, -- Git integration \u0026#34;akinsho/toggleterm.nvim\u0026#34;, -- Terminal management }) Save and exit Neovim, then open it and run:\n:Lazy sync This will install the plugins automatically.\n5. Setting Up Treesitter Treesitter provides better syntax highlighting and code parsing. Install it by adding the following to your init.lua:\nrequire\u0026#39;nvim-treesitter.configs\u0026#39;.setup { ensure_installed = \u0026#34;all\u0026#34;, highlight = { enable = true, }, indent = { enable = true, }, } Then, update Treesitter by running:\n:TSUpdate 6. Setting Up LSP (Language Server Protocol) LSP enables features like code completion and linting. Install LSP servers for your language:\n# Python sudo pacman -S python-lsp-server # C++ sudo pacman -S clang # JavaScript/TypeScript npm install -g typescript-language-server Then, enable LSP support in Neovim:\nlocal lspconfig = require(\u0026#34;lspconfig\u0026#34;) lspconfig.pyright.setup({}) -- Python lspconfig.ts_ls.setup({}) -- JavaScript/TypeScript lspconfig.clangd.setup({}) -- C++ Restart Neovim and check LSP status:\n:LspInfo 7. Enhancing Auto-Completion with nvim-cmp To enable code auto-completion, update your init.lua:\nlocal cmp = require\u0026#39;cmp\u0026#39; cmp.setup({ mapping = { [\u0026#39;\u0026lt;C-Space\u0026gt;\u0026#39;] = cmp.mapping.complete(), [\u0026#39;\u0026lt;CR\u0026gt;\u0026#39;] = cmp.mapping.confirm({ select = true }), }, sources = { { name = \u0026#39;nvim_lsp\u0026#39; }, { name = \u0026#39;buffer\u0026#39; }, { name = \u0026#39;path\u0026#39; }, { name = \u0026#39;luasnip\u0026#39; }, { name = \u0026#39;nvim_lua\u0026#39; }, } }) 9. Final Thoughts Congratulations! You now have a powerful, customized Neovim setup that functions as a full-fledged IDE. With features like Treesitter, LSP support, auto-completion, syntax highlighting, Git integration, and a file explorer, your development workflow will be much smoother.\nIf youâ€™d like to further improve your Neovim experience, explore more plugins and tweak your settings. Good luck with that!\nFurther Reading Neovim Documentation Awesome Neovim Plugins Arch Wiki: Neovim ","permalink":"http://localhost:1313/posts/setting-up-neovim-on-arch-linux-a-beginners-guide/","summary":"\u003ch1 id=\"setting-up-neovim-an-easy-and-beginners-guide\"\u003eSetting Up Neovim: An Easy and Beginner\u0026rsquo;s Guide\u003c/h1\u003e\n\u003cp\u003eNeovim is a modern and extensible text editor that enhances Vimâ€™s capabilities. If you\u0026rsquo;re using Linux, setting up Neovim can be a rewarding experience, allowing you to customize it for an efficient workflow. In this guide, we\u0026rsquo;ll cover installing Neovim, setting up a basic configuration, and enhancing it with essential plugins to turn it into a full-fledged IDE.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-installing-neovim\"\u003e\u003cstrong\u003e1. Installing Neovim\u003c/strong\u003e\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo pacman -S neovim\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003chr\u003e\n\u003ch2 id=\"2-setting-up-neovim-configuration\"\u003e\u003cstrong\u003e2. Setting Up Neovim Configuration\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eNeovimâ€™s configuration is stored in \u003ccode\u003e~/.config/nvim/\u003c/code\u003e. Create the directory and initialize a basic configuration:\u003c/p\u003e","title":"Setting Up Neovim: A Beginner's Guide"},{"content":"Linux Kernal The Linux kernel is a free and open-source, Unix-like kernel widely used in computer systems around the world. Developed by Linus Torvalds in 1991, it was soon adopted as the kernel for the GNU operating system (OS), designed as a free alternative to Unix. Since the late 1990s, the Linux kernel has been included in numerous operating system distributions, many of which are referred to as Linux. One prominent example is Android, a Linux-based operating system widely used in mobile and embedded devices.\nThe majority of the kernel\u0026rsquo;s code is written in C, leveraging extensions provided by the GNU Compiler Collection (GCC) beyond standard C. Additionally, it includes assembly code for architecture-specific functions, such as optimizing memory usage and task execution. Architecturally, the Linux kernel is monolithic, meaning the entire OS operates within kernel space. However, it features a modular design, allowing software components to be integrated as modules, including dynamic loading.\nWhat Is A Kernel Module? A Linux kernel module is precisely defined as a code segment capable of dynamic loading and unloading within the kernel as needed. These modules enhance kernel capabilities without necessitating a system reboot. A notable example is seen in the device driver module, which facilitates kernel interaction with hardware components linked to the system.\n","permalink":"http://localhost:1313/posts/how-to-write-a-custom-kernel-module/","summary":"\u003ch2 id=\"linux-kernal\"\u003eLinux Kernal\u003c/h2\u003e\n\u003cp\u003eThe Linux kernel is a free and open-source, Unix-like kernel widely used in computer systems around the world. Developed by Linus Torvalds in 1991, it was soon adopted as the kernel for the GNU operating system (OS), designed as a free alternative to Unix. Since the late 1990s, the Linux kernel has been included in numerous operating system distributions, many of which are referred to as Linux. One prominent example is Android, a Linux-based operating system widely used in mobile and embedded devices.\u003c/p\u003e","title":"How to Write a Custom Kernel Module"},{"content":"What is it? gh is GitHub\u0026rsquo;s official command-line tool designed to extend Git\u0026rsquo;s functionality with GitHub-specific features.\nPurpose: Simplifies interaction with GitHub\u0026rsquo;s ecosystem directly from the terminal. Allows you to manage repositories and use GitHub features like issues, pull requests, and workflows.\nKey Features: GitHub-specific tasks:\nAuthentication: Easier login (gh auth login) without dealing with tokens manually. Repository Management: Create, fork, or clone repositories. Issues \u0026amp; Pull Requests: Manage issues, PRs, and comments directly. Actions: Manage and view GitHub Actions workflows. Works alongside Git for basic version control tasks. Use Case: Best for developers heavily using GitHub and its features (for example: pull requests, issues, and actions).\nHow it works Install gh:\n\u0026gt; yay -S github-cli Verify the installation:\n\u0026gt; gh --version Login with GitHub CLI (gh)\n\u0026gt; gh auth login Follow the interactive prompts to log in:\nChoose HTTPS or SSH for connection. Log in via a browser using a one-time code or SSH keys. Verify authentication:\n\u0026gt; gh auth status What\u0026rsquo;s best about it that you can install and use both Git and gh (GitHub CLI) seamlessly. Here\u0026rsquo;s how to set them up:\nInstall Git\n\u0026gt;sudo pacman -S git Check the installation:\n\u0026gt; git --version Using Git and gh Together You can now: Use Git for version control:\n\u0026gt; git clone https://github.com/username/repo.git \u0026gt; git add . \u0026gt; git commit -m \u0026quot;message\u0026quot; \u0026gt; git push ","permalink":"http://localhost:1313/posts/github-cli-githubs-official-command-line-tools/","summary":"\u003ch2 id=\"what-is-it\"\u003eWhat is it?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003egh\u003c/strong\u003e is GitHub\u0026rsquo;s official command-line tool designed to extend Git\u0026rsquo;s functionality with GitHub-specific features.\u003c/p\u003e\n\u003ch2 id=\"purpose\"\u003ePurpose:\u003c/h2\u003e\n\u003cp\u003eSimplifies interaction with GitHub\u0026rsquo;s ecosystem directly from the terminal. Allows you to manage repositories and use GitHub features like issues, pull requests, and workflows.\u003c/p\u003e\n\u003ch2 id=\"key-features\"\u003eKey Features:\u003c/h2\u003e\n\u003cp\u003eGitHub-specific tasks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAuthentication: Easier login (gh auth login) without dealing with tokens manually.\u003c/li\u003e\n\u003cli\u003eRepository Management: Create, fork, or clone repositories.\u003c/li\u003e\n\u003cli\u003eIssues \u0026amp; Pull Requests: Manage issues, PRs, and comments directly.\u003c/li\u003e\n\u003cli\u003eActions: Manage and view GitHub Actions workflows.\u003c/li\u003e\n\u003cli\u003eWorks alongside Git for basic version control tasks.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"use-case\"\u003eUse Case:\u003c/h2\u003e\n\u003cp\u003eBest for developers heavily using GitHub and its features (for example: pull requests, issues, and actions).\u003c/p\u003e","title":"GitHub CLI: GitHub's Official Command Line Tools"},{"content":"Connecting a Raspberry Pi 5 to a USB TTY cable is a common way to interact with it through a serial connection, especially for debugging or setting up the device without using a display.\nPrerequists\nRaspberry Pi 5. USB TTY (serial) cable. Computer with a terminal emulator (minicom/screen). GPIO pinout diagram of Raspberry Pi 5 (for reference). Power source for Raspberry Pi (optional if USB TTY can power it, though not recommended). Before Starting! Issuse with firmware UART does NOT work on the RPI5 from the factory. We will need a firmware update to fix this that prevents the dtoverlays for UARTs from working.\nInstall rpi-update with the following commands:\n\u0026gt; sudo curl -L --output /usr/bin/rpi-update https://raw.githubusercontent.com/Hexxeh/rpi-update/master/rpi-update \u0026amp;\u0026amp; sudo chmod +x /usr/bin/rpi-update Then update the firmware on your RPI5 with:\n\u0026gt; sudo rpi-update Enable UART To manually configure UART, you can edit the config.txt file.\nEdit /boot/firmware/config.txt and add:\n\u0026gt; enable_uart=1 How to Connect Locate the GPIO Pins Find the GPIO header on the Raspberry Pi 5. Identify the following pins: GND (Ground): Usually black wire on the USB TTY cable. TX (Transmit): Sends data from the Pi to the computer. RX (Receive): Receives data from the computer to the Pi.\nUse a GPIO pinout chart to locate these pins. For Raspberry Pi 5, it will likely be similar to previous models. Making connections You will need to connect:\nGND with Ground - Pin# 06 TX with GPIO14 - Pin# 08 RX with GPIO15 - Pin# 10 Plug the USB TTY Cable into the Computer\nInsert the USB end of the TTY cable into your computer. The cable will create a virtual COM port (e.g /dev/ttyUSB0). Configure and Access Serial Console\nOpen a terminal.\nIdentify the port with:\n\u0026gt; ls /dev/ttyUSB* Use a terminal emulator like screen or minicom to connect:\n\u0026gt; screen /dev/ttyUSB0 115200 *Replace /dev/ttyUSB0 with the actual port name.\nTurn on the Raspberry Pi. If everything is set up correctly, you should see boot messages in the terminal. Log in to the Pi using the default username (pi) and password (raspberry), or your custom credentials. You should see something similar to this.\nThis is it! You have done it. Congrats!\n","permalink":"http://localhost:1313/posts/how-to-connect-a-raspberry-pi-5-to-usb-tty-cable/","summary":"\u003cp\u003eConnecting a Raspberry Pi 5 to a USB TTY cable is a common way to interact with it through a serial connection, especially for debugging or setting up the device without using a display.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePrerequists\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eRaspberry Pi 5.\u003c/li\u003e\n\u003cli\u003eUSB TTY (serial) cable.\u003c/li\u003e\n\u003cli\u003eComputer with a terminal emulator (minicom/screen).\u003c/li\u003e\n\u003cli\u003eGPIO pinout diagram of Raspberry Pi 5 (for reference).\u003c/li\u003e\n\u003cli\u003ePower source for Raspberry Pi (optional if USB TTY can power it, though not recommended).\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"before-starting\"\u003e\u003cstrong\u003eBefore Starting!\u003c/strong\u003e\u003c/h3\u003e\n\u003ch3 id=\"issuse-with-firmwarehttpsforumsraspberrypicomviewtopicphpt361397p2171244\"\u003e\u003cstrong\u003e\u003ca href=\"https://forums.raspberrypi.com/viewtopic.php?t=361397#p2171244\"\u003eIssuse with firmware\u003c/a\u003e\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eUART does NOT work on the RPI5 from the factory. We will need a firmware update to fix this that prevents the dtoverlays for UARTs from working.\u003c/p\u003e","title":"How to Connect a Raspberry PI 5 to USB TTY Cable"},{"content":"Hosting a website on GitHub Pages with Hugo involves the following steps:\nCreating a website 1. Install Hugo and git\n\u0026gt; sudo pacman -S Hugo 2. Create a new Hugo site\n\u0026gt; hugo new site your-website 3. Add a Theme\nNavigate to your website directory and add a theme. You can choose one from the Hugo Themes .\n\u0026gt; cd your-website \u0026gt; git init \u0026gt; git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/hugo-PaperMod Now you will need to update the hugo.toml file for them to take effect. To do so you can either echo or addd it in the file.\n\u0026gt; echo \u0026quot;theme = 'hugo-PaperMod'\u0026quot; \u0026gt;\u0026gt; hugo.toml To view the website you can run it locally using Hugo\u0026rsquo;s development server to view the site. You can add -D to see your drafts.\n\u0026gt; hugo server 3. Add Content\nTo add a new page to your site.\n\u0026gt; hugo new content content/posts/yout-first-post.md This is it You have done it. YAY!\nHosting it on GitHub 1. Create a GitHub repository.\nClick the + icon in the top-right corner of:\u0026gt; [!WARNING] the GitHub interface and select New repository. Enter a repository name: yourusername.github.io Click Create repository. 2. Add Files for Your website\nClone the repository locally using Git:\ngit clone https://github.com//.git\nAdd your static site files (generated by Hugo) to the repository. Commit and push the changes:\n\u0026gt; git add -A \u0026gt; git commit -s -m \u0026quot;Initial commit\u0026quot; \u0026gt; git push origin main 3. Configure the Repository for GitHub Pages\nGo to the Settings tab of your new repository. Scroll down to the Pages section. Settings \u0026gt; Pages. In the center of your screen you will see this: Build and development Change the Source to GitHub Actions. 4. Create a file named hugo.yaml in a directory named .github/workflows.\n\u0026gt; mkdir -p .github/workflows \u0026gt; cd ./github/workflows touch hugo.yaml 5. Add content in the YAML file.\n# Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: - main # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.141.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v4 with: submodules: recursive fetch-depth: 0 - name: Setup Pages id: pages uses: actions/configure-pages@v5 - name: Install Node.js dependencies run: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34; - name: Build with Hugo env: HUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache HUGO_ENVIRONMENT: production TZ: America/Los_Angeles run: | hugo \\ --gc \\ --minify \\ --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 5. Commit and push your GitHub repository.\n\u0026gt;git add -A \u0026gt;git commit -m \u0026quot;Create hugo.yaml\u0026quot; \u0026gt;git push 6. Deployment status From GitHubâ€™s main menu, choose Actions. When GitHub has finished building and deploying your site, the color of the status indicator will change to green.\nStep 5: Verify Your GitHub Pages Site\nThe site will be live at https://yourusername.github.io.\n","permalink":"http://localhost:1313/posts/hosting-a-website-on-github-pages-with-hugo/","summary":"\u003cp\u003eHosting a website on GitHub Pages with Hugo involves the following steps:\u003c/p\u003e\n\u003ch1 id=\"creating-a-website\"\u003eCreating a website\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e1. Install Hugo and git\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; sudo pacman -S Hugo\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e2. Create a new Hugo site\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; hugo new site your-website\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e3. Add a Theme\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eNavigate to your website directory and add a theme. You can choose one from the \u003ca href=\"https://themes.gohugo.io/\"\u003eHugo Themes\u003c/a\u003e .\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; cd your-website\n\u0026gt; git init \n\u0026gt; git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/hugo-PaperMod\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow you will need to update the hugo.toml file for them to take effect. To do so you can either \u003cem\u003eecho\u003c/em\u003e or addd it in the file.\u003c/p\u003e","title":"Hosting a Website on Github Pages With Hugo"},{"content":"KVM Kernel-based Virtual Machine is a free and open-source virtualization module in the Linux kernel that allows the kernel to function as a hypervisor.\nInstallation For updates, run the following command:\n$ sudo pacman -Syu QEMU/KVM installation: We\u0026rsquo;ll install qemu and all the utils required:\n$ sudo pacman -S qemu vde2 ebtables iptables-nft nftables dms masq bridge-utils ovmf swptm Virtual Machine Manager installation: The virt-manager application is a graphical user interface for managing virtual machines through libvirt. It primarily targets KVM VMs.\n$ sudo pacman -S virt-manager Now everything is set to work. We can move towards downloading archlinux .iso file.\nDownload .iso file: Head towards: https://archlinux.org/download/ Scroll through and look for the server closest to you. Download archlinux-2024.10.01-x86_64.iso file. Setting up: Open terminal and run the following command:\n$ virt-manager You will see an interface similar to this:\nClick on \u0026lsquo;create a new virtual machine\u0026rsquo; (option with star). Select \u0026lsquo;Local install media\u0026rsquo;. Browse to your \u0026lsquo;archlinux-2024.10.01-x86_64.iso\u0026rsquo;. Add your desired VM configuration and create a disk image. Boot Menu: You will be prompted to a boot menu.\nSelect the topmost option to start the installation process. Archlinux Installer: You will be prompted to a terminal. The first step is to check if you are connected to the internet.\nRun:\n# ip addr show If it shows an IP address and says \u0026lsquo;UP\u0026rsquo;, that means you are good to go.\nIf not: You will need to connect to the internet using the \u0026lsquo;iwctl\u0026rsquo; method for Wi-Fi.\n# iwctl To search networks in your vicinity:\n[iwd]# station [your_wifi_interface] get-networks Get the name of the network you want to connect to. Exit from this prompt using \u0026rsquo;exit\u0026rsquo;.\nTo connect to the desired Wi-Fi network, run:\n# iwctl --passphrase \u0026#34;[wifi_password]\u0026#34; station [your_wifi_interface] connect [wifi_name] You can again run ip addr show to check if you are connected to the network.\nNow you can run the installation command. We\u0026rsquo;ll be using the archinstall method.\n# archinstall You will be prompted to an interface similar to this:\nWe will install Arch using this interface. Go through each option:\nArchinstall language: Choose your preferred language. Mirrors: Select the mirror region closest to you. Use \u0026lsquo;/\u0026rsquo; to search. Locales: Set language and keyboard layout. Disk configuration: Choose Best-effort default partition to format the system. Bootloader: Use the default \u0026lsquo;Grub\u0026rsquo; option. Swap: Select Swap on zram (default). Hostname: Leave as it is. Root password: Set the password for sudo/root privileges. User account: Set up a user account. Profile: Select Desktop. It includes essential packages. Others include Minimal, Server, and Xorg. In Desktop, select your desktop environment. We\u0026rsquo;ll use Gnome for simplicity.\nAudio: Use PipeWire (default) or PulseAudio. Kernels: Use the linux kernel. Additional packages: Install any required packages. Network Configuration: Use NetworkManager for a GUI in Gnome. Timezone: Set the timezone closest to you and enable time sync. Press Install. Congratulations! You\u0026rsquo;ve successfully installed Arch Linux.\n","permalink":"http://localhost:1313/posts/arch_kvm/","summary":"\u003ch1 id=\"kvm\"\u003eKVM\u003c/h1\u003e\n\u003cp\u003eKernel-based Virtual Machine is a free and open-source virtualization module in the Linux kernel that allows the kernel to function as a hypervisor.\u003c/p\u003e\n\u003ch2 id=\"installation\"\u003eInstallation\u003c/h2\u003e\n\u003cp\u003eFor updates, run the following command:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$ sudo pacman -Syu\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"qemukvm-installation\"\u003eQEMU/KVM installation:\u003c/h3\u003e\n\u003cp\u003eWe\u0026rsquo;ll install qemu and all the utils required:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$ sudo pacman -S qemu vde2 ebtables iptables-nft nftables dms masq bridge-utils ovmf swptm\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"virtual-machine-manager-installation\"\u003eVirtual Machine Manager installation:\u003c/h3\u003e\n\u003cp\u003eThe virt-manager application is a graphical user interface for managing virtual machines through libvirt. It primarily targets KVM VMs.\u003c/p\u003e","title":"archlinux installation in hypervisor through QEMU/KVM"},{"content":"","permalink":"http://localhost:1313/posts/github-cli-githubs-official-command-line-tool/","summary":"","title":""}]